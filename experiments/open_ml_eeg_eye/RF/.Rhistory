n_h = 20
data = readRDS("data.RDS")
x = lapply(1:n_h,function(x){
data[[x]]$x
}) %>% do.call(rbind,.)
y = lapply(1:n_h,function(x){
data[[x]]$y
}) %>% unlist()
x = rbind(x,data$reference)
y = c(y,data$reference_y)
model = train_tree(x,y)
model$model
eval_tree_data(data$test$x,data$test$y,model$model)
source('~/Desktop/marko_paper/github_code/FederatedLearningViaCoTraining/experiments/open_ml_eeg_eye/prepare_data.R')
source('~/Desktop/marko_paper/github_code/FederatedLearningViaCoTraining/experiments/open_ml_eeg_eye/global_models.R')
eval_tree_data(data$test$x,data$test$y,model$model)
preds = eval_tree_data(data$test$x,data$test$y,model$model)
source('~/Desktop/marko_paper/github_code/FederatedLearningViaCoTraining/experiments/open_ml_eeg_eye/global_models.R')
out_acc
saveRDS("results_rds/global_all_data.RDS",object = list(acc=out_acc,auc=out_auc))
library(magrittr)
results = list()
size = nrow((tmp<-readRDS("data.RDS"))$reference)
print(size)
source('~/Desktop/marko_paper/github_code/FederatedLearningViaCoTraining/experiments/open_ml_eeg_eye/run_core_script.R')
source("models_code.R",local = T)
data = readRDS("data.RDS")
data$reference = data$reference[sample(1:nrow(data$reference),size = input_p),]
set.seed(1231)
n_h = 20
solo = lapply(1:n_h, function(x){
train_test_hospital_solo_tree(x,data)
})
solo_test_acc = lapply(solo,function(x)x$test_acc) %>% unlist()
mean(solo_test_acc)
solo_test_auc = lapply(solo,function(x)x$test_auc) %>% unlist()
mean(solo_test_auc)
hospitals = lapply(1:n_h, function(x){
tmp_data = data[[paste0("hospital_",x)]]
tree = train_tree(tmp_data$x,tmp_data$y)
list(x = tmp_data$x,
y=tmp_data$y,
model=tree)
})
i = 1
current_model = hospitals[[i]]
current_data = current_model
## working data
tmp = data$reference
# tmp = tmp[sample(1:nrow(tmp),size = nrow(tmp)/5),]
## create temp target Y
others = setdiff(1:n_h,i)
other_embeddings = lapply(others,function(x){
tmp_model = hospitals[[x]]
predict(tmp_model$model$model,newdata = as.data.frame(tmp),type = "vote")
})
holder = other_embeddings[[1]]
for(j in 2:length(other_embeddings)){
holder = holder + other_embeddings[[j]]
}
holder = holder/length(other_embeddings)
holder = holder[,2] / (holder[,1] + holder[,2])
new_x = rbind(current_data$x,tmp)
new_y = round(current_data$y,holder)
holder
round(holder)
new_x = rbind(current_data$x,tmp)
new_y = round(current_data$y,round(holder))
tmp_tree = train_tree(new_x,new_y)
dim(new_x)
tmp
dim(new_y)
length(new_y)
new_y = c(current_data$y,round(holder))
new_x = rbind(current_data$x,tmp)
new_y = c(current_data$y,round(holder))
tmp_tree = train_tree(new_x,new_y)
current_model$model = tmp_tree
source('~/Desktop/marko_paper/github_code/FederatedLearningViaCoTraining/experiments/open_ml_eeg_eye/run_core_script.R')
source('~/Desktop/marko_paper/github_code/FederatedLearningViaCoTraining/experiments/open_ml_eeg_eye/run_core_script.R')
plot(test_acc,type="l",ylim = c(0.5,1),main=paste0("Reference size: ",input_p))
lines(test_auc,type="l",col="red")
source('~/Desktop/marko_paper/github_code/FederatedLearningViaCoTraining/experiments/open_ml_eeg_eye/run_core_script.R')
source('~/Desktop/marko_paper/github_code/FederatedLearningViaCoTraining/experiments/open_ml_eeg_eye/run_core_script.R')
output_stats = list(
acc = test_acc,
auc = test_auc
)
results[[length(results)+1]] = output_stats
i = 10000
rm(list = setdiff(ls(),c("results","candidates","i")))
input_p = i
message("Trying : ",input_p)
source("method_core_script.R") ## input P sent to the script --> ugly code
output_stats = list(
acc = test_acc,
auc = test_auc
)
results[[length(results)+1]] = output_stats
names(results) = paste0("ref_size_",candidates)
saveRDS(results,file = "results_rds/our_method_all_data.RDS")
global = readRDS("results_rds/global_all_data.RDS")
rf = readRDS("results_rds/our_method_all_data.RDS")
rf_ = lapply(rf,function(x){
x$acc = (x$acc %>% TTR::SMA(.,n=3)) %>% max(.,na.rm = T)
x$auc = (x$auc %>% TTR::SMA(.,n=3))  %>% max(.,na.rm = T)
x
})
rf
solo_acc = lapply(rf,function(x){
x$acc[1]
}) %>% unlist() %>% mean()
solo_auc = lapply(rf,function(x){
x$auc[1]
}) %>% unlist() %>% mean()
solo_auc
solo_acc
global = readRDS("results_rds/global_all_data.RDS")
rf = readRDS("results_rds/our_method_all_data.RDS")
rf
rf[[13]] = nULL
rf[[13]] = NULL
rf_ = lapply(rf,function(x){
x$acc = (x$acc %>% TTR::SMA(.,n=3)) %>% max(.,na.rm = T)
x$auc = (x$auc %>% TTR::SMA(.,n=3))  %>% max(.,na.rm = T)
x
})
rf_
names(rf)
names(rf)[13]
names(rf)[13] = "ref_size_10000"
rf_ = lapply(rf_,function(x)x$acc) %>% unlist()
rf_ = lapply(rf_,function(x)x$auc) %>% unlist()
library(ggplot2)
library(magrittr)
library(reshape2)
library(grid)
global = readRDS("results_rds/global_all_data.RDS")
rf = readRDS("results_rds/our_method_all_data.RDS")
rf_ = lapply(rf,function(x){
x$acc = (x$acc %>% TTR::SMA(.,n=3)) %>% max(.,na.rm = T)
x$auc = (x$auc %>% TTR::SMA(.,n=3))  %>% max(.,na.rm = T)
x
})
library(ggplot2)
library(magrittr)
library(reshape2)
library(grid)
global = readRDS("results_rds/global_all_data.RDS")
rf = readRDS("results_rds/our_method_all_data.RDS")
rf[[13]] = NULL
names(rf)[13] = "ref_size_10000"
rf_ = lapply(rf,function(x){
x$acc = (x$acc %>% TTR::SMA(.,n=3)) %>% max(.,na.rm = T)
x$auc = (x$auc %>% TTR::SMA(.,n=3))  %>% max(.,na.rm = T)
x
})
solo_acc = lapply(rf,function(x){
x$acc[1]
}) %>% unlist() %>% mean()
solo_auc = lapply(rf,function(x){
x$auc[1]
}) %>% unlist() %>% mean()
acc_ = lapply(rf_,function(x)x$acc) %>% unlist()
auc_ = lapply(rf_,function(x)x$auc) %>% unlist()
global$acc
benchmark_acc = list(
solo = rep(solo_acc,length(acc_)),
global = rep(mean(global$acc),length(acc_)),
ref = acc_,
x = gsub(names(acc_),pattern = "ref_size_",replacement = "") %>% as.numeric()
)
View(benchmark_acc)
benchmark_auc = list(
solo = rep(solo_auc,length(acc_)),
global = rep(mean(global$auc),length(acc_)),
ref = auc_,
x = gsub(names(auc_),pattern = "ref_size_",replacement = "") %>% as.numeric()
)
acc = stringi::stri_list2matrix(benchmark_acc)
acc = apply(acc,2,as.numeric)
auc = stringi::stri_list2matrix(benchmark_auc)
auc = apply(auc,2,as.numeric)
acc = as.data.frame(acc)
auc = as.data.frame(auc)
colnames(acc) = c(
"solo",
"global",
"proposed method",
"Size"
)
colnames(auc) = c(
"solo",
"global",
"proposed method",
"Size"
)
risi = function(acc11=acc,auc11=auc){
# names = c(names,"Size")
tmp1 = melt(acc11,"Size")
tmp2 = melt(auc11,"Size")
one =  ggplot(tmp1, aes(Size,value)) + geom_point(aes(colour = variable),lwd=1.25) +
geom_line(aes(x=Size,y=value,colour = variable),lwd=0.75) +
xlab("Ref. Size") + ylab("Accuracy (test)") + ggtitle("20 hospitals (from 35-65 examples per hosp.):") +
theme(axis.text.x = element_text(angle = 45)) +
scale_x_log10("Ref. Size", labels = as.character(acc11$Size), breaks = acc11$Size)
two = ggplot(tmp2, aes(Size,value)) + geom_point(aes(colour = variable),lwd=1.25) +
geom_line(aes(x=Size,y=value,colour = variable),lwd=0.75) +
xlab("Ref. Size") + ylab("AUC (test)") + ggtitle("20 hospitals (from 35-65 examples per hosp.):") +
theme(axis.text.x = element_text(angle = 45)) +
scale_x_log10("Ref. Size", labels = as.character(acc11$Size), breaks = acc11$Size)
multiplot = function(..., plotlist=NULL, file, cols=1, layout=NULL) {
# Make a list from the ... arguments and plotlist
plots <- c(list(...), plotlist)
numPlots = length(plots)
# If layout is NULL, then use 'cols' to determine layout
if (is.null(layout)) {
# Make the panel
# ncol: Number of columns of plots
# nrow: Number of rows needed, calculated from # of cols
layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
ncol = cols, nrow = ceiling(numPlots/cols))
}
if (numPlots==1) {
print(plots[[1]])
} else {
# Set up the page
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
# Make each plot, in the correct location
for (i in 1:numPlots) {
# Get the i,j matrix positions of the regions that contain this subplot
matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
layout.pos.col = matchidx$col))
}
}
}
list(
ACC = one,
AUC = two
)
}
save.image("~/Desktop/marko_paper/share/for_markdown.RData")
risi = function(acc11=acc,auc11=auc){
# names = c(names,"Size")
tmp1 = melt(acc11,"Size")
tmp2 = melt(auc11,"Size")
one =  ggplot(tmp1, aes(Size,value)) + geom_point(aes(colour = variable),lwd=1.25) +
geom_line(aes(x=Size,y=value,colour = variable),lwd=0.75) +
xlab("Ref. Size") + ylab("Accuracy (test)") + ggtitle("20 hospitals (from 35-65 examples per hosp.):") +
theme(axis.text.x = element_text(angle = 45)) +
scale_x_log10("Ref. Size", labels = as.character(acc11$Size), breaks = acc11$Size)
two = ggplot(tmp2, aes(Size,value)) + geom_point(aes(colour = variable),lwd=1.25) +
geom_line(aes(x=Size,y=value,colour = variable),lwd=0.75) +
xlab("Ref. Size") + ylab("AUC (test)") + ggtitle("20 hospitals (from 35-65 examples per hosp.):") +
theme(axis.text.x = element_text(angle = 45)) +
scale_x_log10("Ref. Size", labels = as.character(acc11$Size), breaks = acc11$Size)
multiplot = function(..., plotlist=NULL, file, cols=1, layout=NULL) {
# Make a list from the ... arguments and plotlist
plots <- c(list(...), plotlist)
numPlots = length(plots)
# If layout is NULL, then use 'cols' to determine layout
if (is.null(layout)) {
# Make the panel
# ncol: Number of columns of plots
# nrow: Number of rows needed, calculated from # of cols
layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
ncol = cols, nrow = ceiling(numPlots/cols))
}
if (numPlots==1) {
print(plots[[1]])
} else {
# Set up the page
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
# Make each plot, in the correct location
for (i in 1:numPlots) {
# Get the i,j matrix positions of the regions that contain this subplot
matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
layout.pos.col = matchidx$col))
}
}
}
list(
ACC = one,
AUC = two
)
}
risi()
risi()[[1]]
risi = function(acc11=acc,auc11=auc){
# names = c(names,"Size")
tmp1 = melt(acc11,"Size")
tmp2 = melt(auc11,"Size")
one =  ggplot(tmp1, aes(Size,value)) + geom_point(aes(colour = variable),lwd=1.25) +
geom_line(aes(x=Size,y=value,colour = variable),lwd=0.75) +
xlab("Ref. Size") + ylab("Accuracy (test)") + ggtitle("RF: 20 hospitals (from 70-130 examples per hosp.)") +
theme(axis.text.x = element_text(angle = 45)) +
scale_x_log10("Ref. Size", labels = as.character(acc11$Size), breaks = acc11$Size)
two = ggplot(tmp2, aes(Size,value)) + geom_point(aes(colour = variable),lwd=1.25) +
geom_line(aes(x=Size,y=value,colour = variable),lwd=0.75) +
xlab("Ref. Size") + ylab("AUC (test)") + ggtitle("RF: 20 hospitals (from 70-130 examples per hosp.)") +
theme(axis.text.x = element_text(angle = 45)) +
scale_x_log10("Ref. Size", labels = as.character(acc11$Size), breaks = acc11$Size)
multiplot = function(..., plotlist=NULL, file, cols=1, layout=NULL) {
# Make a list from the ... arguments and plotlist
plots <- c(list(...), plotlist)
numPlots = length(plots)
# If layout is NULL, then use 'cols' to determine layout
if (is.null(layout)) {
# Make the panel
# ncol: Number of columns of plots
# nrow: Number of rows needed, calculated from # of cols
layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
ncol = cols, nrow = ceiling(numPlots/cols))
}
if (numPlots==1) {
print(plots[[1]])
} else {
# Set up the page
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
# Make each plot, in the correct location
for (i in 1:numPlots) {
# Get the i,j matrix positions of the regions that contain this subplot
matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
layout.pos.col = matchidx$col))
}
}
}
list(
ACC = one,
AUC = two
)
}
risi = function(acc11=acc,auc11=auc){
# names = c(names,"Size")
tmp1 = melt(acc11,"Size")
tmp2 = melt(auc11,"Size")
one =  ggplot(tmp1, aes(Size,value)) + geom_point(aes(colour = variable),lwd=1.25) +
geom_line(aes(x=Size,y=value,colour = variable),lwd=0.75) +
xlab("Ref. Size") + ylab("Accuracy (test)") + ggtitle("RF: 20 hospitals (from 70-130 examples per hosp.)") +
theme(axis.text.x = element_text(angle = 45)) +
scale_x_log10("Ref. Size", labels = as.character(acc11$Size), breaks = acc11$Size)
two = ggplot(tmp2, aes(Size,value)) + geom_point(aes(colour = variable),lwd=1.25) +
geom_line(aes(x=Size,y=value,colour = variable),lwd=0.75) +
xlab("Ref. Size") + ylab("AUC (test)") + ggtitle("RF: 20 hospitals (from 70-130 examples per hosp.)") +
theme(axis.text.x = element_text(angle = 45)) +
scale_x_log10("Ref. Size", labels = as.character(acc11$Size), breaks = acc11$Size)
multiplot = function(..., plotlist=NULL, file, cols=1, layout=NULL) {
# Make a list from the ... arguments and plotlist
plots <- c(list(...), plotlist)
numPlots = length(plots)
# If layout is NULL, then use 'cols' to determine layout
if (is.null(layout)) {
# Make the panel
# ncol: Number of columns of plots
# nrow: Number of rows needed, calculated from # of cols
layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
ncol = cols, nrow = ceiling(numPlots/cols))
}
if (numPlots==1) {
print(plots[[1]])
} else {
# Set up the page
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
# Make each plot, in the correct location
for (i in 1:numPlots) {
# Get the i,j matrix positions of the regions that contain this subplot
matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
layout.pos.col = matchidx$col))
}
}
}
multiplot(
one,two,cols=1
)
}
risi()[[1]]
jpeg(filename = "results_png/RF_eye.png", pointsize =12, quality = 100,width = 2000,height = 1200)
risi()
dev.off()
jpeg(filename = "results_png/RF_eye.JPG", pointsize =12, quality = 100,width = 2000,height = 1200)
risi()
dev.off()
jpeg(filename = "results_png/RF_eye.JPG", pointsize =12, quality = 100,width = 1000,height = 1000)
risi()
dev.off()
source('~/Desktop/marko_paper/github_code/FederatedLearningViaCoTraining/experiments/open_ml_eeg_eye/run_core_script.R')
output_stats = list(
acc = test_acc,
auc = test_auc
)
results[[length(results)+1]] = output_stats
names(results) = paste0("ref_size_",candidates)
saveRDS(results,file = "results_rds/our_method_all_data.RDS")
source('~/Desktop/marko_paper/github_code/FederatedLearningViaCoTraining/experiments/open_ml_eeg_eye/plot_results.R')
source('~/Desktop/marko_paper/github_code/FederatedLearningViaCoTraining/experiments/open_ml_eeg_eye/run_core_script.R')
source('~/Desktop/marko_paper/github_code/FederatedLearningViaCoTraining/experiments/open_ml_eeg_eye/run_core_script.R')
source('~/Desktop/marko_paper/github_code/FederatedLearningViaCoTraining/experiments/open_ml_eeg_eye/run_core_script.R')
source('~/Desktop/marko_paper/github_code/FederatedLearningViaCoTraining/experiments/open_ml_eeg_eye/run_core_script.R')
source('~/Desktop/marko_paper/github_code/FederatedLearningViaCoTraining/experiments/open_ml_eeg_eye/run_core_script.R')
i = 10000
rm(list = setdiff(ls(),c("results","candidates","i")))
input_p = i
message("Trying : ",input_p)
source("method_core_script.R") ## input P sent to the script --> ugly code
setwd("~/Desktop/marko_paper/github_code/FederatedLearningViaCoTraining/experiments/open_ml_eeg_eye/RF")
source("method_core_script.R") ## input P sent to the script --> ugly code
source('~/Desktop/marko_paper/github_code/FederatedLearningViaCoTraining/experiments/open_ml_eeg_eye/RF/plot_results.R')
names(results) = paste0("ref_size_",candidates)
source('~/Desktop/marko_paper/github_code/FederatedLearningViaCoTraining/experiments/open_ml_eeg_eye/RF/run_core_script.R')
source('~/Desktop/marko_paper/github_code/FederatedLearningViaCoTraining/experiments/open_ml_eeg_eye/RF/plot_results.R')
global = readRDS("results_rds/global_all_data.RDS")
rf = readRDS("results_rds/our_method_all_data.RDS")
rf_ = lapply(rf,function(x){
x$acc = (x$acc %>% TTR::SMA(.,n=2)) %>% max(.,na.rm = T)
x$auc = (x$auc %>% TTR::SMA(.,n=2))  %>% max(.,na.rm = T)
x
})
solo_acc = lapply(rf,function(x){
x$acc[1]
}) %>% unlist() %>% mean()
solo_auc = lapply(rf,function(x){
x$auc[1]
}) %>% unlist() %>% mean()
acc_ = lapply(rf_,function(x)x$acc) %>% unlist()
auc_ = lapply(rf_,function(x)x$auc) %>% unlist()
benchmark_acc = list(
solo = rep(solo_acc,length(acc_)),
global = rep(mean(global$acc),length(acc_)),
ref = acc_,
x = gsub(names(acc_),pattern = "ref_size_",replacement = "") %>% as.numeric()
)
benchmark_auc = list(
solo = rep(solo_auc,length(acc_)),
global = rep(mean(global$auc),length(acc_)),
ref = auc_,
x = gsub(names(auc_),pattern = "ref_size_",replacement = "") %>% as.numeric()
)
acc = stringi::stri_list2matrix(benchmark_acc)
acc = apply(acc,2,as.numeric)
auc = stringi::stri_list2matrix(benchmark_auc)
auc = apply(auc,2,as.numeric)
acc = as.data.frame(acc)
auc = as.data.frame(auc)
colnames(acc) = c(
"solo",
"global",
"proposed method",
"Size"
)
colnames(auc) = c(
"solo",
"global",
"proposed method",
"Size"
)
risi = function(acc11=acc,auc11=auc){
# names = c(names,"Size")
tmp1 = melt(acc11,"Size")
tmp2 = melt(auc11,"Size")
one =  ggplot(tmp1, aes(Size,value)) + geom_point(aes(colour = variable),lwd=1.25) +
geom_line(aes(x=Size,y=value,colour = variable),lwd=0.75) +
xlab("Ref. Size") + ylab("Accuracy (test)") + ggtitle("RF 100 trees : 20 hospitals (from 70-130 examples per hosp.)") +
theme(axis.text.x = element_text(angle = 45)) +
scale_x_log10("Ref. Size", labels = as.character(acc11$Size), breaks = acc11$Size)
two = ggplot(tmp2, aes(Size,value)) + geom_point(aes(colour = variable),lwd=1.25) +
geom_line(aes(x=Size,y=value,colour = variable),lwd=0.75) +
xlab("Ref. Size") + ylab("AUC (test)") + ggtitle("RF 100 trees: 20 hospitals (from 70-130 examples per hosp.)") +
theme(axis.text.x = element_text(angle = 45)) +
scale_x_log10("Ref. Size", labels = as.character(acc11$Size), breaks = acc11$Size)
multiplot = function(..., plotlist=NULL, file, cols=1, layout=NULL) {
# Make a list from the ... arguments and plotlist
plots <- c(list(...), plotlist)
numPlots = length(plots)
# If layout is NULL, then use 'cols' to determine layout
if (is.null(layout)) {
# Make the panel
# ncol: Number of columns of plots
# nrow: Number of rows needed, calculated from # of cols
layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
ncol = cols, nrow = ceiling(numPlots/cols))
}
if (numPlots==1) {
print(plots[[1]])
} else {
# Set up the page
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
# Make each plot, in the correct location
for (i in 1:numPlots) {
# Get the i,j matrix positions of the regions that contain this subplot
matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
layout.pos.col = matchidx$col))
}
}
}
multiplot(
one,two,cols=1
)
}
risi()
jpeg(filename = "../results_png/RF_eye.JPG", pointsize =12, quality = 100,width = 1000,height = 1000)
risi()
dev.off()
